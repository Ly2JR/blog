# 装饰模式(Decorator Pattern)

装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。

- 定义

23钟设计模式之一，英文交Decorator Pattern,又叫装饰者模式。装饰者模式是在不比改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。

- 模式特点

（1）装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。

（2）装饰对象包含一个真实对象的引用(reference)。

（3）装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。

（4）装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。

- 适用性

以下情况使用Decorator模式

1、需要扩展一个类的功能，或给一个类添加附近职责。

2、需要动态的给一个对象添加功能，这些功能可以再动态的撤销。

3、需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。

4、当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

- 优点

1、Decorator模式于继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。

2、通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

- 缺点

  1、这种比继承更加灵活动机的特性，也同事意味着更加多的复杂性。

  2、装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。

  3、装饰模式是针对抽象组件(Component)类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现”半透明“的装饰者模式。在实际项目中要做出最佳选择。

  - 设计原则

    1、多组合，少继承。

    利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。

    2、类应设计的对扩展开放，对修改关闭。

- 模式简化

1、如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component.

2、如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。

- 相关区别

1、关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式抓哟是给被装饰者新增新职责的。

2、关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可用认为是其变种--”半透明“装饰者）

3、关于其包裹的对象：适配器是知道被适配者的详细情况的(就是那个类或那个接口)。装饰者只知道其接口是什么，至于其具体类型(是基类还是其他派生类)只又在运行期间才知道。

- 代码示例

在装饰模式中的各个角色有：

（1）抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。

（2）具体构件(Concrete Component)角色：定义一个将要接收附加责任的类。

（3）装饰(Decorator)角色：持有一个构件(Component)对象的实例，并实现一个与抽象构建接口一致的接口。

（4）具体装饰(Concrete Decorator)角色：负责给构建对象添加上附加的责任。

以下示例中，ThirdParty.cs假定是一个现有的或者第三方的功能，因某种原因我们不能直接修改，它提供了一个SayMsg()的方法，而我们要做的是想在它的SayMsg()方法中增加一些我们想额外输出的内容，于是我们重写了一个Decorator.cs类。

```cs
using System;
class DecoratorPattern{
  interface IThirdParty{
    string SayMsg();
  }

  class ThirdParty:IThirdParty{
    public string SayMsg(){
      return "Hello";
    }
  }

  class Decorator1:IThirdParty{
    private IThirdParty _thirdParty;

    public Decorator1(IThirdParty thirdParty){
      this._thirdParty=thirdParty;
    }

    public string SayMsg(){
      return $"##1{_thirdParty.SayMsg()}##1";
    }
  }

  class Decorator2:IThirdParty{
     private IThirdParty _thirdParty;

    public Decorator2(IThirdParty thirdParty){
      this._thirdParty=thirdParty;
    }

    public string SayMsg(){
      return $"##2{_thirdParty.SayMsg()}##2";
    }
  }

  static void Main(string[] args){
    var thirdPartyOne=new ThirdParty();
    var decorator1=new Decorator1(thirdPartyOne);
    var decorator2=new Decorator2(decorator1);
    Console.WriteLine(decorator2.SayMsg());
  }
}
```

- 组合模式(Composite Pattern)

组合模式，将对象组合秤树形结构以表示"部门-整体"的层次结构。

- 组合模式概述

  组合模式使得用户对单个对象喝组合对象的使用具有一致性。

  有时候又叫做部分-整体模式，它使完美树型结构的问题中，模糊了简单元素喝复杂元素的概念，客户程序可以处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

  组合模式让你可以优化处理递归或分级模式结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的`文件系统`。文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式Composite。

  - 定义

    （GOF《设计模式》）:将对象组合成树形结构以表示“部门整体“的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

  - 涉及角色

    1. Component是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。
    2. Leaf 在组合中表示叶子节点对象，叶子节点没有子节点。
    3. Composite定义有枝界节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(`add`)和删除(`remove`)等。

  - 适用性

  以下情况下使用Composite模式：

    1. 你想表达对象的部分-整体层次结构
    2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

- 总结

  组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。

  如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。本章使用了一个文件系统的例子来说明了组合模式的用途。在这个例子中，文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，从而实现将文件或者目录存储为目录的子级元素。

- 示例
